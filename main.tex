\documentclass[modern]{aastex61}
\usepackage{xspace}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\newcommand{\escapecmd}[1]{\texttt{\detokenize{#1}}}

\submitjournal{ApJ}

\shorttitle{Astropy Project II}
\shortauthors{Astropy Project et al.}

% Packages / projects / programming - for consistency!
\newcommand{\package}[1]{\texttt{#1}\xspace}
\newcommand{\github}{\package{GitHub}}
\newcommand{\python}{\package{Python}}
\newcommand{\astropy}{Astropy\xspace}
\newcommand{\astropypkg}{\package{astropy}}

% For consistency:
\newcommand{\sectionname}{Section\xspace}
\renewcommand{\figurename}{Figure\xspace}
\newcommand{\equationname}{Equation\xspace}
\renewcommand{\tablename}{Table\xspace}

% For commenting - can be deleted before submission
\usepackage[colorinlistoftodos]{todonotes}
\newcommand{\inlinecomment}[2]{\todo[inline]{#1: #2}\xspace}
\newcommand{\comment}[2]{\todo{#1: #2}\xspace}

\begin{document}

\draft{\today}

\title{The Astropy Project}

\correspondingauthor{Astropy Coordination Committee}
\email{coordinators@astropy.org}

\author{Astropy Collaboration}

\begin{abstract}
% I (Adrian) took a first stab at the abstract, but it needs some work. Feel
% free to modify!
The \astropy project supports and fosters the development of open-source and openly-developed
\python packages that provide commonly-needed functionality to the astronomical
community.
A key element of the project is the \astropy core package, which serves as the
foundation for more specialized projects and packages.
In this article, we provide an overview of the organization of the \astropy
project and summarize key features in the core package as of the recent major
release, version 2.0.
We then describe the project infrastructure designed to facilitate and support
development for a broader ecosystem of inter-operable packages.
We conclude with a future outlook of planned new features and directions for the
broader \astropy project.
\end{abstract}

%% Keywords should appear after the \end{abstract} command.
%% See the online documentation for the full list of available subject
%% keywords and the rules for their use.
\keywords{}

\section*{\textit{Notes and guidelines (to be removed)}}

\begin{itemize}
   \item The goal is to produce a brief and informative paper that covers major
        \astropy principles not mentioned in the first paper, the core v2.0
        package, and infrastructure in \astropy project to support development
        in \python.
    \item We don't plan on including code in this paper, but if you think you
        will need to include code in your section, please add it to a separate
        Python module (.py file) and include it in this repository.
    \item Use \escapecmd{\sectionname} not ``Section,'' \escapecmd{\figurename}
        not ``Figure''
    \item Use \escapecmd{\astropypkg} for the astropy package,
        \escapecmd{\astropy} for the astropy project, \escapecmd{\python} not
        ``Python''
    \item If your subpackage was included in Paper I, then please just include a
        note on what the package does, a reference to paper I, and any new major
        updates to your package
    \item If your subpackage was not included, then please describe the
        sub-package on level with what was in the first paper, and highlight any
        major features in it. Typical length should be equivalent to one page
        (single-column).
    \item Please make sure you are logged into Overleaf or pushing a commit with
        your information to be able to track the contributors to the paper.

\end{itemize}

\section*{Global TODO items}
\begin{itemize}
    \item subpackage not sub-package!
    \item spell check!
\end{itemize}


\section{Introduction} \label{sec:intro}
% first draft by Moritz (hamogu)
% heavily edited by Adrian PW - let me know if you want to revert anything!
All astronomical research makes use of software in some way.
Astronomy as a field has thus long supported the development of software tools
for astronomical tasks, from software packages that enable individualized
scientific research to data reduction tools and pipelines that enable
collaborations and survey operations.
Some such software packages are or were supported by large institutions and are
intended for a wide range of users.
These packages typically provide some level of documentation and user support or
training.
Other packages are developed by individual researchers or research groups and
are then typically used by smaller groups for more domain-specific purposes.
Whether for a package meant for wide distribution or for scripts and programs
for a specific research project, the implementation of astronomical software can
be eased through the use of a library that provides core functionality that is
common to many astronomical tasks.
The users of such software then also benefit from a community and ecosystem
built around a common foundation.
The \astropy project has grown to become this community, and the \astropypkg
core package a feature-rich library for \python-based astronomical software.

The development of the \astropypkg core package began as a largely
community-driven effort to standardize core functionality for astronomical
software in \python.
In this way, its genesis differs from but builds upon many substantial and
former astronomical software development efforts that were commissioned or
initiated through large institutional support, for example IRAF \citep[developed
at NOAO;][]{IRAF}, MIDAS \citep[developed at ESO;][]{MIDAS}, or Starlink
\citep[originally developed by a consortium of UK institutions and now
maintained by the East Asian Observatory;][]{starlink1982,starlink2013}.
% More recently, community-driven efforts have seen significant success in the astronomical sciences \citep{yt}

The \astropypkg core package is now a feature-rich library of sufficiently
general tools and classes that supports the development of more specialized
code.
An example of such functionality is reading and writing FITS files: it would be
time consuming and impractical for multiple groups to implement the FITS
standard \citep{FITS} and maintain software for such a general-purpose need.
Another example of such a common task is in dealing with representations of and
transformations between astronomical coordinate systems.
The \astropy project aims to provide an open-source, open-development core
package (\astropypkg) and an ecosystem of \emph{affiliated packages} that
support astronomical functionality in the \python programming language.

\python\footnote{\url{https://www.python.org/}} is an increasingly popular,
general-purpose scripting language that is available under a permissive open
source software license free of charge for all major operating systems.
Stable and well-developed packages provide support for array arithmetic
\citep[\package{numpy};][]{numpy}, a wide variety of functions for scientific
computing \citep[\package{scipy};][]{numpy}, and publication-quality plotting
\citep[\package{matplotlib};][]{matplotlib}. Tens of thousands of other packages
are available which can help with tasks that are not astronomy specific but
might be performed in the course of astronomical research, for example interfacing with databases or statistical inference.

\python has become especially popular in the quantitative sciences, especially
where researchers must simultaneously produce research, perform data analysis,
and develop software.
A large part of this success owes itself to a vibrant community of developers
and a continuously-growing ecosystem of tools and web services that enable
easier collaboration on software development, easier writing and sharing
documentation, and continuous testing and validation of software.
More recently, package managers such as
Anaconda\footnote{\url{https://anaconda.org/}} have streamlined the installation
process for most packages, therefore significantly reducing the barrier to entry
for using many such libraries.

The \astropy project aims to develop and provide high quality code and
documentation according to the best practices in software development.
The project makes use of these tools to do so without central institutional
oversight.
The first public release of the \astropypkg package is described in
\cite{astropy}. Since then, the \astropypkg package has been
used in hundreds of projects, and the scope of the package has grown
considerably. At the same time, the community of astronomers
contributing to the project has grown tremendously and an ecosystem
of packages supporting or affiliated with the \astropypkg core has
developed.
In this paper, we describe the current status of the \astropy community and the
\astropypkg core package and discuss goals for future development

We start by describing the way the \astropy project functions and is organized
in \sectionname~\ref{sec:org}. We then describe the main software efforts
developed by the \astropy project itself: a core package called \astropypkg
(\sectionname~\ref{sec:core}) and several separate packages that help maintain
the infrastructure for, e.g., testing and documentation
(\sectionname~\ref{sec:infrastructure}). We end with a short vision for
the future of \astropy in particular and astronomical software in general
in \sectionname~\ref{sec:future}.

\section{Organization and infrastructure}
\label{sec:org}

\subsection{Coordination of Astropy}
% draft by ??
% edited by Adrian PW

From its inception, \astropy has required coordination to ensure the project as a whole and its coding efforts are consistent and reasonably efficient.
While many Python projects adopt a ``Benevolent Dictator For Life'' (BDFL) model, \astropy has instead opted for a \emph{coordination committee}.
This is in part due to the nature of the project as a large-scale collaboration between many contributors with many interests, and in part due to simply the amount of work that needs to get done.
In part for the latter reason, the project has expanded the committee from three to four members starting in 2016.

For resolving disagreements about the \astropypkg core package or other \astropy-managed code, the coordination committee primarily acts to work toward consensus, or when consensus is difficult to achieve, generally acts as ``tie-breaker.''
The committee also oversees affiliated package applications to ensure they are in keeping with \astropy's vision and philosophy, as well as the associated procedures.
Additionally, the committee oversees the assignment of roles (primarily driven by already-existing contributions), and increasingly has acted as the ``face'' of the Project, providing contact with organizations like NumFOCUS (the body that holds any potential funding in trust for \astropy) or the American Astronomical Society (AAS).


\subsection{APEs - Astropy Proposals for Enhancement}
% draft by hamogu
% edited by Adrian PW

Central to the success of \astropy is an open environment where anybody can
contribute to the project by opening a so-called ``pull request'' with a new
contribution on a publically available
website.\footnote{\url{https://github.com/astropy/astropy}}
This request is then reviewed by at least one of the maintainers responsible for
the specific subpackage or content and is possibly merged into the main code
base.
Most bug fixes, documentation edits, and small features are contributed in this
way.
However, this model leads to ``organic'' growth where different features are
implemented by different people with different programming styles and
interfaces.
Thus, \astropy has a mechanism to more formally propose significant changes to
the core package (e.g., the release cycle; \citealt{ape2}), to plan out major
new features, or institute new organization-wide policies (e.g.,
\citealt{ape8}).
This mechanism is called ``Astropy Proposal for Enhancement'' (APE) and are
modeled after the ``Python Enhancement Proposals'' (PEP) and guide the
development of the \python programming language.
In an APE one or more authors describe in detail the proposed changes or
additions, including a rationale for the changes, how these changes will be
implemented, and, in the case of code, what the interface will be \citep{ape1}.
The APEs are discussed and refined by the community before much work is invested
into a detailed implementation; anyone is welcome to contribute to these
discussions during the open consideration period by leaving comments on the
respective pull request.\footnote{\url{https://github.com/astropy/astropy-APEs}}
In previous APEs a community consensus emerged and APEs are accepted and become
the basis for future work at this point.
In cases where consensus cannot be reached, the
\astropy coordination committee can decide to close the discussion and
make an executive decision based on the community input on the APE in question.

\subsection{Astropy development model}
% draft by Adrian PW and Erik T.

Code is contributed to the \astropypkg core package or modified through ``pull
requests'' (via \github) that often contain several \texttt{git} commits.
Pull requests may fix bugs, implement new features, or improve or modify the
infrastructure that supports the development and maintenance of the package.
Individual pull requests are generally limited to a single conceptual addition
or modification to make code review tractable.
Pull requests that modify or add code to a specific subpackage must be reviewed
and approved by one of the subpackage maintainers before it is merged into the
core codebase.
Bugs and feature requests are reported via the \github issue tracker and labeled
with a set of possible labels that help classify and organize the issues.
The development workflow is detailed in the \astropypkg
documentation.\footnote{\emph{How to make a code contribution}, \url{http://docs.
astropy.org/en/stable/development/workflow/development_workflow.html}}

As of version 2.0, \astropypkg contains $212244$ lines of code\footnote{This
line count includes comments, as these are often as important for
maintainability as the code itself.  Without comments there are $142197$ lines
of code.} contributed by $232$ unique contributors over $19270$ \texttt{git}
commits.
The commit distribution follows an approximate power-law (with log-slope of
$\sim -0.47$), meaning most of the commits were and are contributed by a
relatively small fraction of the contributor pool.
$\approx 50$ percent of the commits were contributed by the top $4$
contributors, while $\sim 90$ percent of the commits came from the top $24$
contributors.

\subsection{Concept of affiliated packages}
% it may be described in previous subsection, if not the Brigitta can try to
% write it up
% edited by Adrian PW

A major part of the \astropy project is the concept of
``Affiliated Packages''. An affiliated package is an astronomy-related
\python package that is not part of the \astropypkg core package, but
has requested to be included as part of the \astropy project's
community. These packages support the goals and vision of \astropy of
improving code reuse, interoperability, and embracing good coding
practices such as testing and thorough documentation.
Affiliated packages contain functionality that is more specialized,
have license incompatibilities, or have external dependencies (e.g., GUI
libraries) that make these packages more suitable to be separate from the
\astropypkg core package.
Affiliated packages may also be used to develop substantial, new functionality
that will eventually be incorporated into the \astropypkg core package: as
initially separate packages, the typically rapid development or new,
experimental features may benefit from having a release cycle that is not tied
to the \astropypkg core.

\inlinecomment{APW}{This needs to be finished:}
In general we hope that becoming an affiliated package is seen as
a good way for new and existing packages to gain exposure.
%
\inlinecomment{BMS}{TODO: write about the process of becoming affiliated, and project packages into the future section below}

%\subsection{Mixin}

%\subsection{Accuracy testing across many different implementation}

\subsection{Release cycle and Long Term Support}
% This could also include information about the development cycle
% Brigitta can writes this up if there's no other taker
% edited by Adrian PW

The \astropypkg has a regular release schedule consisting of new significant
releases every 6 months, with bugfix releases as needed \citep{ape2}.
The major releases will contain new features or any significant changes, whereas
the bugfix releases only contain fixes to code or documentation but no new
features.
Some versions are additionally designated as ``Long-term support'' (LTS)
releases, which continue to receive bugfixes for 2 years following the release
with no changes to the API.
The LTS versions are ideal for pipelines and other applications where API
stability is essential.
The latest LTS release (v2.0) is also the last one that supports \python 2, and
will receive bug fixes until the end of 2019 \citep{ape10}.

The version numbering of the \astropypkg core package reflects this release
scheme: the core package version number uses the form x.y.z, where ``x'' is
advanced for LTS releases, ``y'' is advanced for non-LTS feature releases, and
``z'' is advanced for bugfix releases.

\subsection{Distribution packages}

\astropypkg is available from several of the Python distributions for scientific
% * <mattwcraig@gmail.com> 2017-10-27T07:13:51.093Z:
%
% > \astropypkg i
% I changed a few of the macros in here to refer to the package rather than the project because it is the package being discussed here.
%
% ^.
computing, such as Anaconda or Enthought Canopy, which include also some of
\astropy's affiliated packages.
Alternatively, \astropypkg can be readily installed from the Python Package
Index\footnote{\url{https://pypi.python.org/pypi}} (PyPI) using pip, the
recommended command-line tool for installing Python packages
that is included by default since Python 2 $\geq$ 2.7.9 and Python 3 $\geq$ 3.4.
For most recent \astropypkg releases, pre-built wheel distributions are obtainable
from PyPI for Windows, Mac OS X and Linux systems that provide faster
installation compared to the source distribution.  Optionally, the version of
the package and the dependencies needed to run or build the software are given
by a specifier to the pip package manager as described in PEP 440\footnote{For
more detailed installation instructions and optional flags see
\url{http://docs.astropy.org/en/stable/install.html\#installing-astropy}}.

Packaged versions of \astropy are also available for several
operating systems that are managed by a system's package manager,
including Debian, Ubuntu, Fedora, Gentoo, Arch Linux, Mac OS X (e.g.,
via brew, macports or fink) and FreeBSD.  However, on occasion these packages
may be outdated compared with the latest stable release of \astropy accessible
from the PyPI. Pre-built binary conda packages for all of the affiliated packages are also available  via the \texttt{astropy} conda channel for the three major platforms.
% * <mattwcraig@gmail.com> 2017-10-27T07:16:27.310Z:
%
% > re-built binary conda packages
% Feel free to remove if this is too detailed. I do think the available of the whole ecosystem across all platforms has helped speed its adoption.
%
% ^.

%\subsection{Support of Astropy}
% Removing unless this gets written about in
% a later version
% This section should be a straight forward/factual description of the current
% funding and support provided to astropy with the purpose of explaining the
% current structure to the community


%\subsection{Difficulty of reversing design choices}
%Deciding if a feature should be included
%difficulty to decide where general use ends and "handy feature for some" starts, i.e. how to reject PRs or deal with maintenance burden

\section{Astropy Core Package v2.0}
\label{sec:core}
% Adrian
The \astropy project aims to provide \python-based packages for all tasks that
are commonly needed in a large subset of the astronomical community.
At the foundation is the \astropypkg core package, which provides general
functionality (e.g., coordinate transformations, reading and writing astronomical
files) or base classes for other
packages to utilize for a common interface (e.g., \texttt{NDData}).
In this section, we highlight new features introduced or substantially improved
since version v0.2 (previously described in \citealt{astropy}).

\inlinecomment{BMS}{The itemizations below look very weird being boldface under a much less prominent subsection title. would it be nicer in the final version if we leave it as is in the draft?}

% \subsection{Analytic Functions}
% moved to models and depreciated --
% just here for completeness at the moment
\inlinecomment{BMS}{I suggest to order the subsection lexicographically as reading the draft the current order seemed very random (unlike at the docs page where they the grouping logic is obvious)}

\subsection{Units}\label{sec:units}
% Adrian

The \texttt{astropy.units} subpackage adds support for representing units and
numbers with associated units --- ``quantities'' --- in code.
Historically, quantities in code have often been represented simply as numbers,
with units implied or noted via comments in the code because of considerations
about speed: having units associated with numbers inherently adds overhead to
numerical operations.
In \texttt{astropy.units}, \texttt{Quantity} objects subclass the \texttt{numpy}
array object and has been designed with speed in mind.
As of \astropypkg version 2.0, units and quantities are prevalent in most other
\astropypkg subpackages and are thus a key concept for using the package as a
whole.
Units are intimately entwined in the definition of astronomical coordinates and
thus nearly all functionality in the \texttt{astropy.coordinates} subpackage
(see \sectionname~\ref{sec:coordinates}) depends on this functionality.
For most other subpackages, quantities are at least accepted, and often expected
by default.

The motivation and key concepts behind this subpackage were described in detail
in the previous paper \citep{astropy}, and thus here we primarily highlight new
features and improvements.

\begin{description}
    \item[Interaction with \package{numpy} arrays] The \texttt{Quantity} object
        is now a subclass of the \texttt{numpy.ndarray} object and therefore
        works well with many of the functions in \texttt{numpy} that support
        array operations. For example, \texttt{Quantity} objects with angular
        units can be passed in to the trigonometric functions implemented in
        \texttt{numpy} (e.g., \texttt{numpy.cos}) and do the right thing: the
        units are internally converted to radians (what the \texttt{numpy}
        trigonometric functions expect) before being passed to \texttt{numpy}.
    \item[Speed improvements] The \texttt{Quantity} object is now significantly
        faster than in early versions of \astropypkg. This is in large part due
        to the fact that \texttt{Quantity} subclasses the \texttt{numpy.ndarray}
        object, but even relative to more recent versions of \astropypkg,
        operations with \texttt{Quantity} objects are generally faster. This is
        largely thanks to improvements in the way \texttt{numpy} arrays can be
        subclassed.
    \item[Logarithmic units and magnitudes] By default, taking the logarithm of
        a \texttt{Quantity} object with non-dimensionless units intentionally
        fails.
        However, some well-known units are actually logarithmic quantities,
        where the logarithm of the value is taken with respect to some reference
        value.
        Examples include astronomical magnitudes, which are logarithmic fluxes,
        and decibels, which are more generic logarithmic ratios of quantities.
        Logarithmic, relative units are now supported in \texttt{astropy.units}.
    \item[Using quantities in tables] The \texttt{astropy.table} subpackage (see
        \sectionname~\ref{sec:table}) now supports using quantities in tables
        with the \texttt{QTable} class.
        As a result, units specified in FITS tables are supported, and tables
        with quantities can be read and written to various file formats.
    \item[Defining functions that require quantities] When writing code or
        functions that expect \texttt{Quantity} objects, we often want to
        enforce that the input units have the correct type.
        For example, we may want to require only length-type \texttt{Quantity}
        objects.
        These requirements often lead to implementing repetitive code for
        validating \texttt{Quantity} inputs.
        \texttt{astropy.units} now provides a \python decorator,
        \texttt{quantity\_input()}, that does this verification automatically.
\end{description}

\subsection{Constants}
% David S.
% Edited by Adrian PW

The \texttt{astropy.constants} subpackage provides a selection of physical and
astronomical constants as \texttt{Quantity} objects (see
\sectionname~\ref{sec:units}).
A brief description of this package was given in \citep{astropy}.
In version 2.0, the built-in constants have been organized into modules for
specific versions of the constant values.
For example, physical constants have \texttt{codata2014} \citep{codata2014} and
\texttt{codata2010} versions.
Astronomical constants are organized into \texttt{iau2015} and \texttt{iau2012}
modules to indicate their sources (resolutions from the International
Astronomical Union, IAU).
The \texttt{codata2014} and \texttt{iau2015} versions are combined into the
default constant value version: \texttt{astropyconst20}.
For compatibility with \astropypkg version 1.3 and earlier, the \texttt{astropyconst13}
namespace is still available and provides access to the adopted versions of the
constants from earlier versions of \astropypkg.
To use previous versions of the constants as \emph{units} (e.g., solar masses),
the values from the desired namespace have to be imported directly; with version
2.0, \texttt{astropy.units} uses the \texttt{astropyconst20} versions.

Astronomers using \texttt{astropy.constants} should take particular note of the
constants provided for Earth, Jupiter, and the Sun.
Following IAU 2015 Resolution B3 \citep{iau2015b3}, nominal values are now given
for mass parameters and radii.
The nominal values will not change even as ``current best estimates'' are
updated.

\subsection{Coordinates}
\label{sec:coordinates}
% Adrian, Erik

\subsubsection{Overview}
The \package{astropy.coordinates} subpackage is designed to support representing
and transforming celestial coordinates and, new in version 2.0, velocities.
The framework heavily relies on the \package{astropy.units} subpackage, and most
inputs to objects in this subpackage are expected to be \texttt{Quantity}
objects.
Some of the machinery also relies on the Essential Routines of Fundamental
Astronomy (ERFA) \texttt{C} library for some of the critical underlying
transformation machinery \citep{erfa}, which is based on the Standards Of
Fundamental Astronomy (SOFA) effort \citep{sofa}.

A key concept behind the design of this subpackage is that coordinate
\textit{representations} and \textit{reference systems / frames} are independent
of one another.
For example, a set of coordinates in the International Celestial Reference
System (ICRS) reference frame could be represented as spherical (right
ascension, declination, and distance from solar system barycenter) or Cartesian
coordinates ($x$, $y$, $z$ with the origin at ).
They can therefore change representations independent of being transformed to
other reference frames (e.g., the Galactic coordinate frame).

The classes that handle coordinate representations (the \texttt{Representation}
classes) act like three-dimensional vectors and thus support vector arithmetic.
The classes that represent reference systems and frames (the \texttt{Frame}
classes) internally use \texttt{Representation} objects to store the coordinate
data---that is, the \texttt{Frame} classes accept coordinate data, either as a
specified \texttt{Representation} object, or using short-hand keyword arguments
to specify the components of the coordinates.
These preferred representation and short-hand component names differ between
various astronomical reference systems.
For example, in the ICRS frame, longitude and latitude are right ascension
(\texttt{ra}) and declination (\texttt{dec}), whereas in the Galactic frame, the
spherical angles are Galactic longitude (\texttt{l}) and latitude (\texttt{b}).
Each of the \texttt{Frame} classes define their own component names and
preferred \texttt{Representation} class.
The frame-specific component names map to corresponding components on the
underlying \texttt{Representation} object that internally stores the coordinate
data.
For most frames the preferred representation is spherical, although this is
determined primarily by the common use in the astronomical community.

Many of the \texttt{Frame} classes also have attributes specific to the
corresponding reference system that allow the user to specify the frame.
For example, the Fifth Fundamental Catalogue (FK5) reference system requires
specifying an equinox to determine the reference frame.
If required, these additional frame attributes must be specified along with the
coordinate data when a \texttt{Frame} object is created.
\figurename~\ref{fig:frame-transform-graph} shows the network of possible
reference frame transformations as currently implemented in
\texttt{astropy.coordinates}.
Custom, user-implemented \texttt{Frame} classes that define transformations to
any reference frame in this graph can then be transformed to any of the other
connected frames.

\begin{figure}
\includegraphics[width=\textwidth]{coordinates_graph.pdf}
\caption{%
    The full graph of possible reference frame transformations implemented in
    \texttt{astropy.coordinates}.
    \label{fig:frame-transform-graph}
}
\end{figure}

The typical user doesn't usually have to interact with the \texttt{Frame} or
\texttt{Representation} classes directly.
Instead, \texttt{astropy.coordinates} provides a high-level interface to
representing astronomical coordinates through the \texttt{SkyCoord} class.
The \texttt{SkyCoord} class was designed to provide a single class that
accepts a wide range of possible inputs.
It supports coordinate data in any coordinate frame in any representation by
internally using the \texttt{Frame} and \texttt{Representation} classes.

\subsubsection{Key new features}

\begin{description}
    \item[Local Earth coordinate frames] In addition to representing celestial
    coordinates, \astropypkg now supports specifying positions on the Earth in
    a number of different geocentric systems with the \texttt{EarthLocation}
    class.
    With this, \astropypkg now supports Earth-location-specific coordinate
    systems such as the altitude-azimuth (\texttt{AltAz}) or horizontal system.
    Transformations between \texttt{AltAz} and any Barycentric coordinate frame
    also requires specifying a time using the \texttt{Time} class from
    \texttt{astropy.time}.
    With this new functionality, many of the common tasks associated with
    observation planning can now be completed with \astropypkg or the
    \astropy-affiliated package \package{astroplan}\citep{astroplan_AAS}.

    \item[Proper motion and velocity transformations]
    In addition to positional coordinate data, the \texttt{Frame} classes now
    also support velocity data.
    As the default representation for most frames is spherical, most of the
    \texttt{Frame} classes expect proper motion and radial velocity components
    to specify the velocity information.
    The names of the proper motion components all start with \texttt{pm} and
    adopt the same longitude and latitude names as the positional components.
    Transforming coordinates with velocity data is also supported, but in some
    cases the transformed velocity components have limited accuracy because the
    transformations are done numerically.
    The visualization of the coordinate frame transform graph highlights which
    velocity transformations can be done exactly and which transformations are
    done using a finite-difference scheme.
    The low-level interface for specifying and transforming velocity data (see
    the next point) is currently experimental.
    As such, in v2.0, only the \texttt{Frame} classes (and not the
    \texttt{SkyCoord} class) support handling velocities.

    \item[Derivatives of coordinate representations]
    As mentioned above, the \texttt{Representation} classes act like
    three-dimensional vectors.
    \texttt{astropy.coordinates} now also supports handling first derivatives of
    vectors / representations through the new \texttt{Differential} classes.
    The \texttt{Differential} classes are currently used internally within the
    \texttt{Frame} classes to store the velocity data.

    \item[Solar System Ephemerides]
    Also new is support for computing ephemerides of major solar system bodies
    and outputting the resulting positions as coordinate objects.
    These ephemerides can be computed either using analytic approximations from
    ERFA, or from downloaded JPL ephemerides (the latter requires the
    \package{jplephem}\footnote{\url{https://github.com/brandon-rhodes/python-jplephem}}
    optional dependency and an internet connection).
    The \texttt{get\_body} and \texttt{get\_body\_barycentric} functions provide
    the gateway to this functionality, yielding \texttt{SkyCoord} objects given
    a specific body and choice of ephemeris source.

\end{description}

\subsubsection{Accuracy of coordinate transformations}

\inlinecomment{TR}{This is a first draft and I need to dig into the details again to finish some of the text, and I also need to make the table/figure}.

In order to check the accuracy of the coordinate transformations in \package{astropy.coordinates}, we have set up a set of benchmarks that we use to compare transformations between a set of coordinate frames for a number of packages \footnote{\url{http://www.astropy.org/coordinates-benchmark/summary.html}}. Since
no package can be guaranteed to implement all transformations to arbitrary precision, and since some transformations are sometimes subject to interpretation of standards (in particular in the case of Galactic coordinates), we do not designate any of the existing packages as the `ground truth' but instead compare each tool to all other tools to find. The benchmarks are thus useful beyond the Astropy project since they allow all of the tools to be compared to all other tools. The tools included in the benchmark at the moment include astropy, kapteyn, novas, palpy, pyast, and pyslalib. \textbf{NEED REFS}

The benchmarks are meant to evolve over time and include an increasing variety of cases. At the moment, the benchmarks are set up as follows - we have generated a standard set of 1000 pairs of random longitudes/latitudes that we use in all benchmarks. Each benchmark is then defined using an input and output coordinate frame, using all combinations of FK4, FK5, Galactic, ICRS and Ecliptic frames. For now we set the epoch of observation to J2000, and the frame to J2000 in the case of the FK5 and ecliptic frames and B1950 for the FK4 frame, but in future we plan to include a larger variety of epochs and equinoxes, as well as tests of conversion to/from Altitude/Azimuth.

For each benchmark, we convert the 1000 longitudes/latitudes from the input/output frame with all tools and quantify the comparison by looking at the median, minimum, maximum, and standard deviation of the absolute separation of the output coordinates from each pair of tools. Table \textbf{TODO} gives an example of the relative accuracy of the conversion from Galactic to FK4 coordinates for all pairs of tools. This shows that \textbf{Need to add discussion here}.

The benchmarks also include all-sky plots that show trends in accuracy over the sky and can help diagnose issues. Figure \textbf{TODO} shows an example of the accuracy of the conversion from XX to XX and \textbf{insert insightful result here}.

%\subsubsection{Accuracy and comparison of coordinate system definitions}
% Erik?

\subsection{Time}
\label{sec:time}


\inlinecomment{Tom, Marten?}

\inlinecomment{SCO}{Q: does it make sense to refer forward to FITS support, even though it is 3.0?-- If you want to say something add it to the future section, but I'd say no.}

Time and date functionality, especially those relevant to astronomy, are dealt by the \package{Time} package.  The package was described in detail in \cite{astropy}.  The \package{Time} package is currently built on ERFA \citep{erfa}, which replicates the functionality of SOFA \cite{sofa} but is licensed under a three-clause BSD license.

\subsection{Data arrays}

\subsubsection{nddata}

\inlinecomment{Should I mention the fact that there will be changes coming to 3.0? -- If you want to say something add it to the future section}

The \package{astropy.nddata} supackage provides three types of functionality:
an abstract interface for representing generic arbitrary-dimensional datasets
intended primarily for developers of other packages, concrete classes
building on this interface and utilities for manipulating these kind of
datasets.

The \texttt{NDDataBase} class provides the abstract interface for gridded data with attributes for accessing metadata, the world-coordinate system (WCS), uncertainty and other traits. Building on this interface the \texttt{NDData} class provides a minimally working implementation for storing NumPy arrays. These classes serve as useful base for package authors wishing to develop their own classes for specific use cases and as containers for exchanging gridded data.

The concrete classes \texttt{NDDataRef}, \texttt{NDDataArray} and \texttt{CCDData} extend the storing functionality with options to do basic arithmetic (addition, subtraction, multiplication and division) including error propagation in limited cases and slicing of the dataset based on grid coordinates appropriately handling mask, errors, and units, if present. Additionally \texttt{CCDData} also provides I/O from and to FITS files and uses data structures from \astropypkg, like WCS, to represent the contents of a file abstractly.

The \package{astropy.nddata.utils} module provides utilities that can operate on either plain NumPy arrays or any of the classes in the \package{astropy.nddata} subpackage.  It features a class for representing two-dimensional image cutouts, allowing one to easily link pixels in the cutout to pixels in the original image or from the image to the cutout, to convert between world and pixel coordinates in the cutout and to overlay the cutout on images. Functions to enlarge or reduce an image by doing block replication or reduction are also provided.


%Larry:  Don't forget the nddata.utils functionality (e.g. Cutout2D, block\_reduce, %etc.).

\subsubsection{Tables}
\label{sec:table}

The \package{Tables} package provides wrappers to \package{NumPy} structure arrays, which can contain heterogeneous data sets.   The package was described in detail in \cite{astropy}. Tables now has the ability to work with other astropy classes including Quantities, Time, and Coordinates.  In addition, operations can also be performed on Tables.

%QTable is new, mixin columns for time and coordinates. Table operations were added in v0.3

\subsection{io}
% Simon

The \package{astropy.io} subpackage provides support for reading and writing
various formats: a wide range of ASCII data table formats, FITS, VOTable, etc.
It also provides a unified interface for reading and writing data with these
different formats, using the \package{astropy.table} subpackage.
For many common cases this simplifies the process of file I/O and reduce the
need to master the separate details of all the I/O packages within Astropy.
% This functionality is still in active development and the number of supported
% formats will be increasing.

%\inlinecomment{SCO}{Pyfits deprecation in favor of io.fits ?}
%\inlinecomment{SCO}{Table and FITS tables}

%\subsubsection{Unified file read/write interface}

%\inlinecomment{Check when it was added (0.3?). Overview of the supported formats (ASCII,FITS, votable, HTML, JSViewer/Datatables).}

\subsubsection{Key new features}


\begin{description}

    \item[ASCII: fast reader/writer]

		The \package{astropy.io.ascii} module now includes a significantly faster
		Cython/C engine for reading and writing ASCII files. This is available
		for the following formats: basic, commented\_header, csv, no\_header,
		rdb, and tab.  On average the new engine is about 4 to 5 times faster
		than the corresponding pure-Python implementation, and is often
		comparable to the speed of the pandas ASCII file interface. The fast
		reader has parallel processing option that allows harnessing multiple
		cores for input parsing to achieve even greater speed gains.

		By default, read() and write() will attempt to use the fast C engine when
		dealing with compatible formats. Certain features of the full read / write
		interface are not available in the fast version, in which case the
		pure-Python version will automatically be used.

    \item[ASCII: HTML tables]

		The \package{astropy.io.ascii} subpackage now provides the capability
		to read a table within an HTML file or web URL into an astropy
		\texttt{Table} object. This requires the \package{BeautifulSoup4}
		package to be installed.  Conversely a \texttt{Table} object can now
		be written out as an HTML table.

	\item [Enhanced CSV format ]

		One of the problems when storing a table in an ASCII format is
		preserving table meta-data such as comments, keywords and column data
		types, units, and descriptions. Using the newly defined \emph{Enhanced
		Character Separated Values} (ECSV) format it is now possible to write
		a table to an ASCII-format file and read it back with no loss of
		information. The ECSV format has been designed to be both
		human-readable and compatible with most simple CSV readers.

	\item [FITS: command-line scripts (\texttt{fitsheader}, \texttt{fitsinfo})]

		The \package{astropy.io.fits} subpackage now provides a command line
		script for inspecting the header(s) of a FITS file.  Running
		\texttt{fitsheader file.fits} in a terminal prints the header
		information to the screen in a human-readable format. Run
		\texttt{fitsheader --help} to see the full usage documentation.

	\item [FITS: lazy loading ]

		The \package{astropy.io.fits} subpackage now supports \emph{lazy
		loading}, where all HDUs are not loaded until they are requested (or
		the file is closed). This should provide substantial speedups for
		situations using the convenience functions (e.g., \texttt{getheader()}
		or \texttt{getdata()}) to get HDU’s that are near the front of a file
		with many HDU’s.

	\item [Misc: YAML serialization ]

		The new \package{astropy.io.misc.yaml} module allows converting
		astropy objects into a standard YAML format.
        This can be used beyond \texttt{astropy.io.misc.yaml}: for example, to
        serialize the metadata of tables before saving to other formats like
        HDF5.

\end{description}

%\inlinecomment{BMS}{Maybe move the command line tools into a separate subsection to highlight them (even though we mostly only have fits related scripts)? They are supposed to be used more frequently by individual users.}
%\inlinecomment{hamogu}{MY feeling is that this section is too detailed already. If I had written it, I would not have mentioned the scripts at all.}

\subsection{Modeling}
\label{sec:modeling}
% The whole modeling submodule was missing from the previous paper, so everything really, including compound models, unit support etc.
% Nadia, Lim
% Tom R. -- unit support
\subsubsection{Overview}
The \package{astropy.modeling} subpackage provides a framework for representing
analytical models and performing model evaluation and fitting. Models and
fitters are independent of each other, a model can be fit with different
fitters and new fitters can be added without changing existing models. The
framework is designed to be flexible and easily extensible. The goal is to have
a rich set of models but also make it easy to create new ones if necessary. The
modeling framework is used in a variety of data analysis tools and is the basis
for the Generalized World Coordinate System (GWCS)
package\footnote{\url{https://github.com/spacetelescope/gwcs}}. The
unit support in models and fitters make it a unique package for working with
astrophysical models.

\subsubsection{Single Model Definition and Evaluation}
Most models are defined by parameters and maintain an ordered list of parameter names, \texttt{Model.param\_names}. A model is instantiated by passing in values (scalars or arrays) for its parameters. A parameter is a descriptor that provides a proxy for the value and stores additional information -- default value, default unit, and parameter constraints. The value and constraints can be updated by assignment. Supported parameter constraints include \texttt{fixed}, and \texttt{tied} parameters, and \texttt{bounds} on parameter values. Most models have a fixed parameter set but for some (e.g., polynomials), the number of parameters is defined by another argument (e.g., degree-of-freedom in the case of polynomials). Parameters support arithmetic operations and are combined with the inputs during evaluation using the numpy broadcasting rules. A model is evaluated by calling it as a function and passing the inputs in as arguments.

Models have \texttt{Model.inverse} property, which returns the analytical inverse, if available, or raises an exception otherwise. This is a settable property; i.e., a model instance can be assigned as inverse to another model. For example, a polynomial model can be assigned as an inverse for another polynomial model.

Another useful settable property of models is \texttt{Model.bounding\_box}. It defines the limits over which the model is significant. This greatly improves the efficiency of evaluation when the input range is much larger than the characteristic width of the model itself.

\subsubsection{Model Sets}

\package{astropy.modeling} provides an efficient way to instantiate the same type of model with many different sets of parameter values by passing the \texttt{n\_models=k} keyword, where k is the number of models to instantiate, and providing the values for each parameter as an iterable of size k. This creates a model set which is efficiently evaluated. Model sets are most useful for efficiently fitting multiple linear models of the same kind.

\subsubsection{Compound Models}
Single models can be combined using arithmetic expressions. The result is also a model, which can further be combined with other models. Modeling supports arithmetic (+, -, *, /, and **), join $\&$, and composition $|$ operators. The rules for combining models involve matching their inputs and outputs. For example, the composition operator, $|$, requires the number of outputs of the left model to be equal to the number of inputs of the right one. For the join operator, the total number of inputs must equal the sum of number of inputs of both the left and the right models. For all arithmetic operators, the left and the right models must have the same number of inputs and outputs.

\subsubsection{Fitting Models to Data}

\package{astropy.modeling} provides several fitters which are wrappers around some of the \texttt{numpy} and \texttt{scipy.optimize} functions and provide supports for constraints. They take a model as input and return a copy of the model with the fitted parameters. The goal is to make it easy to extend the fitting framework and create new fitters. The optimizers available in \astropypkg 2.0 are Levenberg-Marquardt, Simplex, SLSQP, and LinearLSQFitter (which is based on \texttt{numpy.linalg} that provides exact solution for linear models).

Modeling also supports a plugin system for fitters, which allows using the
astropy models with external fitters. An example of this is
\package{SABA}\footnote{\url{https://github.com/astropy/saba}}, which is a bridge between
Sherpa\footnote{\url{http://cxc.cfa.harvard.edu/contrib/sherpa/}}
and \package{astropy.modeling}, to bring the Sherpa fitters into astropy.

\subsubsection{Creating New Models}

New model classes can be created in two ways:
\begin{itemize}
   \item The simplest way is to use the \texttt{custom\_model} decorator in modeling with a user defined function which takes the inputs and model parameters as arguments.
   \item It is also possible to subclass the \texttt{Model} base class and create an arbitrary complex custom model.
\end{itemize}

\subsubsection{Unit Support}

The \package{modeling} package now supports the representation, evaluation and fitting of models using \texttt{Quantity} objects, which attach units to scalar values or arrays of values. In practice, this means that one can for example fit a model to data with units and get parameters that also have units out, or initialize a model with parameters with units and evaluating it using input values with different but equivalent units. Using this, we have implemented a blackbody model (\texttt{BlackBody1D}) that can be used to fit observed fluxes in a variety of units and as a function of different units of spectral coordinates.

\subsection{Convolution}
% Adam G.

\astropypkg implements `normalized convolution' \citep[e.g.,][]{Knutsson1993}, which is an image reconstruction technique in which missing data are ignored during the convolution and replaced with values interpolated using the kernel.   In version $<=1.3$, the direct convolution and fft convolution approaches were not consistent, with fft convolution implementing normalized convolution and direct convolution implementing a different approach.  As of v2.0, the two methods are consistent and include a suite of consistency checks.


\begin{figure}
\includegraphics[width=\textwidth]{convolution_example.png}
\caption{%
    An example showing different modes of convolution available in the \python
    ecosystem.  The red x's mark pixels that are set to NaN in the original data
    (a).  If the data are convolved with a Gaussian kernel on a 9x9 grid using
    scipy's direct convolution (b), any pixel within range of the original NaN
    pixels is also set to NaN.  Panel (c) shows what happens if the NaNs are set
    to zero first: the originally NaN regions are depressed relative to their
    surroundings.  Finally, panel (d) shows \astropypkg's convolution behavior,
    where the missing pixels are replaced with values interpolated from their
    surroundings using the convolution kernel.
    \label{fig:convolution-example}
}
\end{figure}


\subsection{Visualization}
% Larry:  Image visualization (stretching, scaling), RGB

The \package{visualization} package provides functionality that can be helpful when visualizing data. This includes a framework for plotting astronomical images with coordinates with Matplotlib (previously the standalone \package{wcsaxes} package), functionality related to image normalization (including both scaling and stretching), smart histogram plotting, RGB color image creation from separate images, and custom plotting styles for Matplotlib.

\subsubsection{Image Stretching and Normalization}

\label{sec:stretch}

The \package{visualization} package provides a framework for transforming values in images (and more generally any arrays), typically for the purpose of visualization. Two main types of transformations are normalization and stretching of image values.

Normalization transforms the images values to the [0:1] range using lower and upper limits where $x$ represents the values in the original image:

\begin{equation}
y = \frac{x - v_{vmin}}{v_{max} - v_{min}}
\end{equation}

Stretching transforms the image values in the [0:1] range to the [0:1] range using a linear or non-linear function:
\begin{equation}
z = f(y)
\end{equation}

Several classes are provided for determining intervals (e.g. using image percentiles) and for normalizing values in this interval to the [0:1] range.

\package{Matplotlib} allows a custom normalization and stretch to be used when displaying data by passing a normalization object.  The \package{visualization} package also provides a normalization class that wraps the interval and stretching objects into a normalization object that \package{matplotlib} understands.

\subsubsection{Plotting image data with world coordinates}

One of the most common tasks by astronomers dealing with observational data is to make figures with images that include the correct coordinates and optionally with a coordinate grid. The challenge however is that the conceptual coordinate axes (such as longitude/latitude) need not be lined up with the pixel axes of the image. The \package{visualization.wcsaxes} subpackage implements a generalized way of making figures from an image array and a world coordinate system (WCS) object that provides the transformation between pixel and `world' coordinates. World coordinates can be for example right ascension and declination, but can also include for example velocity, wavelength, frequency, time, and so on. The main features from this subpackage include the ability to control which axes to show which coordinate on (for example showing longitude ticks on the top and bottom axes and latitude on the left and right axes), controlling the spacing of the ticks either by specifying the positions to use or providing a tick spacing or an average number of ticks that should be present on each axis, setting the format for the tick labels to ones commonly used by astronomers, controlling the visibility of the grid/graticule, and overlaying ticks, labels, and/or grid lines from different coordinate systems. In addition, it is possible to pass data with more than two dimensions and slice on-the-fly. Finally, it is possible to define non-rectangular frames, such as for example for Aitoff projections.

This subpackage differs from APLpy \citep{aplpy} in that the latter focuses on providing a very high-level interface to plotting that requires very few lines of code to get a good result, whereas WCSAxes defines an interface that is much closer to that of Matplotlib \citep{matplotlib}, and makes it possible to make significantly more advanced visualizations. An example of a visualization made with \package{wcsaxes} is shown in Figure~\ref{fig:wcsaxes} -- this example illustrates the ability to overlay multiple coordinate systems and customize which ticks/labels are shown on which axes around the image. This also uses the image stretching functionality from Section~\ref{sec:stretch} to show the image in a square root stretch (automatically updating the tick positions in the colorbar).

\begin{figure}
\includegraphics[width=\textwidth]{cygnus_x_spitzer.pdf}
\caption{%
An example of figure made using the \package{visualization.wcsaxes} subpackage, using \textit{Spitzer}/IRAC 8.0$\mu$m data from the Cygnus-X Spitzer Legacy survey \citep{cygnusx}.
\label{fig:wcsaxes}
}
\end{figure}

\subsubsection{Choosing Histogram Bins}

The package also provides the a histogram function, which is a generalization
of \package{matplotlib}’s histogram function, to allow for more flexible
specification of histogram bins.  The function provides several methods of
automatically tuning the histogram bin size. It has a syntax identical to
\package{matplotlib}’s histogram function (with the exception of the bins
parameter), which allows specification of one of four different methods for
automatic bin selection.

\subsubsection{Creating color RGB images}

\cite{Lupton2004} describe an ``optimal'' algorithm for producing red-green-blue (RGB) composite images from three separate high-dynamic range arrays. The \package{visualization} package provides a convenience function to create such a color image.  It also includes an associated set of classes to provide alternate scalings.
This functionality was contributed by developers from the Large Synoptic Survey Telescope (LSST) and serves as an example of contribution to Astropy from a more traditional engineering organization \citep{lsst_astropy}.
% Please cite the final SPIE paper here rather than the presentation slides at that conference.
% https://ui.adsabs.harvard.edu/#abs/2016SPIE.9913E..0GJ/abstract (I'm not sure how to edit the bib file on overleaf)

The Sloan Digital Sky Survey (SDSS) SkyServer color images were made using a variation on this technique.  As an example, in \figurename~\ref{fig:ngc6977} we show an RGB color image of the Hickson 88 group, centered near NGC~6977.  This image was generated from SDSS images using the \package{astropy.visualization} tools.

\begin{figure}
\includegraphics[width=\textwidth]{ngc6977.png}
\caption{An RGB color image of the region near the Hickson 88 group
constructed from SDSS images and the \package{astropy.visualization}
tools.
\label{fig:ngc6977}}
\end{figure}

%\subsection{Utils}
% Lim

\subsection{Cosmology}

The \package{cosmology} package contains classes for representing different cosmologies and functions for calculating commonly used quantities such as look-back time and distance.   The package was described in detail in \cite{astropy}.  The  default cosmology in \astropy v2.0 is given by the values in \cite{2016A&A...594A..13P}

\subsection{Statistics}

The \package{astropy.stats} package provides statistical tools that
are useful for or specific to astronomy and are not found in or extend
the available functionality of other \python\ statistics packages such
as \package{scipy} \citep{scipy} or \package{statsmodels}
\citep{seabold2010statsmodels}.  The \package{stats} package contains
a range of different functionality used by many different disciplines
in astronomy.  It is not a complete set of statistic tools, but rather
a still growing collection of useful features.

The current review process for contributions to the \package{stats} package includes review of the code, documentation, testing, and scientific merit of the inclusion.  When necessary, scientific reviewers outside of the maintainers will be sought for their input on new pull requests.

In this section, we describe these tools that provide a range of different functionality including robust statistical estimators, circular statistics, periodograms, spatial statistics, and histogram binning.


% Steve C.: overview, circular stats,
% Jake V.:  Lomb-scargle, Bayesian blocks
% Larry:  sigma clipping, biweight stats
% Ze':  Ripley's K (spatial stats)

\subsubsection{Robust Statistical Estimators}

Robust statistics provide reliable estimates of basic statistics for complex distributions that largely mitigate the effects of outliers. The \package{stats} package includes several robust statistical functions that are commonly used in astronomy. This includes sigma clipping methods for rejecting outliers, median absolute deviation functions, and biweight estimators, which have been used to calculate the velocity dispersion of galaxy clusters \citep{Beers1990}.

\subsubsection{Circular Statistics}

A set of circular statistical estimators based on \citet{JammalamadakaSengupta}
are implemented in the \package{stats} package.  These functions provide
measurements of the circular mean, variance, and moment.   For all of these
functions, they work with both \texttt{numpy.ndarrays} (assumed to be in
radians) and \texttt{Quantity} objects.  In addition, the package includes
tests for Rayleigh Test, vtest, and a function to compute the maximum likelihood estimator for the parameters of the von Mises
distribution.

\subsubsection{Lomb-Scargle Periodograms}
Periodic analysis of unevenly-spaced time series is common across subfields of Astronomy. The \package{stats} package now includes several efficient implementations of the Lomb-Scargle periodogram \citep{Lomb76, Scargle82} and several generalizations, including floating mean models \citep{Zechmeister09}, truncated Fourier models \citep{Bretthorst2003}, and appropriate handling of heteroscedastic uncertainties. Importantly, the implementations make use of several fast and scalable computational approaches \citep[e.g.][]{Press89, Palmer09}, and so can be applied to much larger datasets than Lomb-Scargle algorithms available in, e.g. \package{scipy.stats} (\citealt{scipy}). Much of the Lomb-Scargle code in AstroPy has been adapted from previously-published open-source code \citep{astroML, VanderPlas2015}.

\subsubsection{Bayesian Blocks and Histogram Binning}
AstroPy also includes an implementation of {\it Bayesian Blocks} \citep{Scargle2013}, an algorithm for analysis of break-points in non-periodic astronomical time-series. One interesting application of Bayesian Blocks is its use in determining optimal histogram binnings, and in particular binnings with unequal bin sizes. This code was adapted, with several improvements, from the \package{astroML} package \citep{astroML}. An example of a histogram fit using the Bayesian blocks algorithm is shown in the right panel of \figurename\ref{fig:bayes-blocks-hist}.

\begin{figure}
\includegraphics[width=\textwidth]{bayesian_blocks_hist.pdf}
\caption{%
    A histogram with irregular bins, fit using the Bayesian blocks
    algorithm. The left panel shows a standard histogram using
    \package{matplotlib}'s default of 10 bins. The right panel shows
    the same histogram with bin widths determined by the Bayesian
    blocks model. The model is such that relevant features of the data
    distribution are much more apparent.
    \label{fig:bayes-blocks-hist}
}
\end{figure}

\section{Infrastructure for affiliated packages}
\label{sec:infrastructure}
%\inlinecomment{BMS}{should we use links to the appropriate github repo?}
%\inlinecomment{PLL}{IMHO a list of GitHub repo links for affil. pkgs. should be in appendix, if included.}
\inlinecomment{BMS}{should we describe astropy-helpers even though it's future is unsure?}
%
\par In addition to astronomy related packages and libraries, the \astropy
Project also maintains and distributes several generic purpose infrastructure packages.
The following sections describes the most widely used selection of them.
%
\subsection{Package template}
% Brigitta may write this up if there is no other takers
%
\par \astropy provides the \package{package-template}\footnote{\url{https://github.com/astropy/package-template/}}
package. Using this template, any \python package can make use of the ready-to-go package
layout, setup, installation and documentation infrastructure developed originally for the
\astropypkg core package and affiliated packages maintained by the \astropy. It also provides
a testing framework, CI templates and configurations, Cython integration, and documentation
on how to make it all work.
%
\subsection{Continuous integration helpers}
% Brigitta
%
\package{ci-helpers}\footnote{\url{https://github.com/astropy/ci-helpers}} is a
collection of scripts that empowers package maintainers to control their testing
set up and installation process for
various continuous integration services via a set of environment
variables. While the current development is mostly driven by the needs of
the \astropy ecosystem, the actual usage of this package is extremely
widespread. Currently we support setups for Travis CI and Appveyor CI.
%
\subsection{Sphinx extensions}

The documentation for many Python packages the core \package{astropy} package
as well as for all packages in the Astropy ecosystem is written using the
Sphinx package. This package makes it possible to write the documentation using
plain text files that follow a markup language called reStructuredText, and
Sphinx can then transform this into HTML or \LaTeX{} documentation. As part of
the project, we have developed a few extensions that facilitate generating
documentation for a large project like Astropy. One of the main extensions we
have developed is
\package{sphinx-automodapi}\footnote{\url{http://sphinx-automodapi.readthedocs.io}},
which makes it easy with a single reStructuredText command to generate a set of
documentation pages listing all the available classes, functions, and
attributes in any given Python module.

\inlinecomment{TPR}{We should put the releases of sphinx-automodapi on Zenodo and cite this}

% TODO: need to put releases of sphinx-automodapi on Zenodo!

%\inlinecomment{BMS}{What about pytest-astropy, should we inlude it here, or
%  for the future section?}
%\inlinecomment{PLL}{pytest-astropy is v3, right?}
% \section{State of the Ecosystem}
% Commenting out unless a clear statement is added

\section{The future of the Astropy project}
\label{sec:future}
\inlinecomment{PLL}{In addition to PY3, add some killer features that we
  plan to implement for 3.0 and beyond?}
\inlinecomment{BMS}{Some killer features we already know about to definitely
have may be mentioned here. e.g. functionality of astropy-healpix? or the
performance/speedup focus of the 3.1 release?}
\inlinecomment{BMS}{should we mention the refactored infra here?
  e.g. pytest-astropy and sphinx-astropy?}
\inlinecomment{SMC}{I've added a rough first draft -- please feel free to edit}
%\subsection{Roadmap for \python 3 only support}

Development has continued after the release of v2.0 of \package{astropy}.    The most significant development for the next release will be removing python 2 support \cite{ape10}.   While the v2.0 release is a ‘long term stable’ release )meaning that it will be supported through 2019 in both python 2 and python 3), the v3.0 \package{astropy} release will only support python 3.  This will allow the use of the new functionality in python 3, simplify the code base, and reducing the testing overhead.   The v3.0 release is currently scheduled for December 2017.

In the release cycle after v3.0, the \astropy project will focus on optimization of the code and improved documentation for the v3.1 release.   To prepare for this release, software for testing and monitoring the performance of the code are being developed.   Less new functionality may be introduced in this release, but the focus will be primarily on improved performance.  In addition, a new suite of tutorials and documentation are being prepared for this release.

Beyond the core code, the \astropy project is also further developing the affiliated packages.  This includes elevating a suite of packages into part of the core project.    While these may not be integrated into the core code, these projects provide code that is useful to the astronomical community and meet the testing and documentation standards of \astropy.   Some of these new efforts includes an initiative to develop tools for spectroscopy , integration of LSST software , and packages to support HEALPIX projection.


\subsection{Learn Astropy}
% Adrian

The \astropypkg core package documentation contains narrative descriptions of
the package functionality along with detailed usage notes for functions,
classes, and modules.
While useful as a reference and for more advanced \python users, it is not the
right entry-point for all users or learning environments.
In the near future, we will launch a new resource for learning to use both the
\astropypkg core package and the many packages in the broader \astropy
ecosystem, under the name `\emph{Learn Astropy}.'

The new \emph{Learn Astropy} site will present several different ways to engage
with the \astropy ecosystem:
\begin{description}
    \item[Documentation] The \astropypkg and affiliated package documentation
        contain the complete description of a package with all requisite
        details, including usage, dependencies, and examples.
        The pages will largely remain as-is, but will be focused towards more
        intermediate users and as a reference resource.
    \item[Examples] These are stand-alone code snippets that live in the
        \astropypkg documentation that demonstrate a specific functionality
        within a subpackage.
        The \astropypkg core package documentation will then gain a new ``index
        of examples'' that links to all of the code or demonstrative examples
        within any documentation page.
    \item[Tutorials] The \astropy tutorials are step-by-step demonstrations of
        common tasks that incorporate several packages or subpackages.
        Tutorials are more extended and comprehensive than examples, may contain
        exercises for the users, and are generally geared towards workshops or
        teaching.
        Several tutorials already
        exist\footnote{\url{http://tutorials.astropy.org/}} and are being
        actively expanded.
    \item[Guides] These are long-form narrative, comprehensive,
        conceptually-focused documents (roughly one book chapter in length)
        providing stand-alone introductions to core packages in addition to the
        underlying astronomical concepts.
        These are less specific and more conceptual than tutorials.
        For example, ``using \astropypkg and \package{ccdproc} to reduce imaging
        data.''
\end{description}
We encourage any users who wish to see specific material to either contribute or
comment on these efforts via the \astropy mailing list or \astropy-tutorials
\github repository.\footnote{\url{https://github.com/astropy/astropy-tutorials}}

\section{Outlook}
\label{sec:outlook}
\inlinecomment{hamogu}{This may be merged into the section above once
  that is fleshed out a little more.}  As shown above the development
of the \astropypkg package is making good progress, helping
astronomers worldwide to perform many daily tasks such as planning
observations, analyzing data or simulation results, and writing
publications. The strong emphasis that the \astropy project puts on
reliability and code correctness helps users to trust the calculations
performed with \astropypkg and to publish reproducible results. More
functionality is added to the core package and more and more
affiliated packages support more specialized needs.

At the same time, \astropy is spreading awareness of best practices in
software development. This is important since most practicing
astronomers received their education without being taught in computer
science and software development although a major fraction of almost
every astronomer's workload today is related to software use and
development. The \astropypkg package leads by example, showing all interested
astronomers how modern tools like git version control or continuous
integration (code is tested after every change to the source) can
increase the quality and accessibility of astronomical software
without overly complicating the development cycle. All submitted code
is reviewed by at least one, but typically more, members of the
\astropy community, providing feedback and allowing contributors to
improve their skill is developing software without the need for their
institutions to provide dedicated teaching resources. Thus, the
\astropy project does not only build the tools needed to perform
productive astronomical research in an era of increasingly large and
complex datasets, it also helps to prepare the current and the next
generation of researchers with the knowledge to adequately use those
tools.


\acknowledgments

Who to thank?  numfocus, GSOC, Python Software Foundation

Software/services to thank: GitHub. Travis CI, Appveyor, CircleCI. Read the Docs.

%% Similar to \facility{}, there is the optional \software command to allow
%% authors a place to specify which programs were used during the creation of
%% the manusscript. Authors should list each code and include either a
%% citation or url to the code inside ()s when available.

\software{\package{astropy} (\citealt{astropy}),
          \package{numpy} (\citealt{numpy}),
          \package{scipy} (\citealt{scipy}),
          \package{matplotlib} (\citealt{matplotlib})
          \package{Cython}(\citealt{cython}),
          }

\bibliographystyle{aasjournal}
\bibliography{bibliography}


\appendix
\section{List of Affiliated Packages}

\begin{longrotatetable}
  \begin{deluxetable*}{ccccc}
    \tablecaption{Registry of affiliated packages.}
    \label{tab:registry}
    \tablehead{
        \colhead{Package Name} &
        \colhead{Stable} &
        \colhead{PyPI Name} &
        \colhead{Maintainer} &
        \colhead{Citation}
      }
      \startdata
        \input{registry.tex}
      \enddata
  \end{deluxetable*}
\end{longrotatetable}

\begin{deluxetable*}{cccc}
  \tablecaption{Registry of provisionally accepted affiliated packages.}
  \label{tab:registry_prov}
    \tablehead{
        \colhead{Package Name} &
        \colhead{Stable} &
        \colhead{PyPI Name} &
        \colhead{Maintainer}
      }
    \startdata
      \input{registry_prov.tex}
    \enddata
\end{deluxetable*}

\end{document}
